// This file is @generated by prost-build.
/// Payment represents one account's desire to trade funds with another account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payment {
    /// source is the account that created this Payment. It is considered the owner of the payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// source_amount is the funds that the source is will pay the target in exchange for the target_amount.
    /// A hold will be placed on this amount in the source account until this Payment is accepted, rejected or cancelled.
    /// If the source_amount is zero, this Payment can be considered a "payment request."
    #[prost(message, repeated, tag = "2")]
    pub source_amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// target is the account that can accept this Payment.
    /// The target is the only thing allowed to change in a payment.
    /// I.e. it can be empty initially and updated later as needed.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// target_amount is the funds that the target will pay the source in exchange for the source_amount.
    /// If the target_amount is zero, this Payment can be considered a "peer-to-peer (P2P) payment."
    #[prost(message, repeated, tag = "4")]
    pub target_amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// external_id is used along with the source to uniquely identify this Payment.
    ///
    /// A source can only have one Payment with any given external id.
    /// A source can have two payments with two different external ids.
    /// Two different sources can each have a payment with the same external id.
    /// But a source cannot have two different payments each with the same external id.
    ///
    /// An external id can be reused by a source once the payment is accepted, rejected, or cancelled.
    ///
    /// The external id is limited to 100 bytes. An empty string is a valid external id.
    #[prost(string, tag = "5")]
    pub external_id: ::prost::alloc::string::String,
}
/// MarketAccount is an account type for use with the accounts module to hold some basic information about a market.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketAccount {
    /// base_account is the base cosmos account information.
    #[prost(message, optional, tag = "1")]
    pub base_account: ::core::option::Option<cosmos_sdk_proto::cosmos::auth::v1beta1::BaseAccount>,
    /// market_id is the numerical identifier for this market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// market_details is some human-consumable information about this market.
    #[prost(message, optional, tag = "3")]
    pub market_details: ::core::option::Option<MarketDetails>,
}
/// MarketDetails contains information about a market.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketDetails {
    /// name is a moniker that people can use to refer to this market.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// description extra information about this market. The field is meant to be human-readable.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// website_url is a url people can use to get to this market, or at least get more information about this market.
    #[prost(string, tag = "3")]
    pub website_url: ::prost::alloc::string::String,
    /// icon_uri is a uri for an icon to associate with this market.
    #[prost(string, tag = "4")]
    pub icon_uri: ::prost::alloc::string::String,
}
/// MarketBrief is a message containing brief, superficial information about a market.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketBrief {
    /// market_id is the numerical identifier for this market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// market_address is the bech32 address string of this market's account.
    #[prost(string, tag = "2")]
    pub market_address: ::prost::alloc::string::String,
    /// market_details is some information about this market.
    #[prost(message, optional, tag = "3")]
    pub market_details: ::core::option::Option<MarketDetails>,
}
/// Market contains all information about a market.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Market {
    /// market_id is the numerical identifier for this market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// market_details is some information about this market.
    #[prost(message, optional, tag = "2")]
    pub market_details: ::core::option::Option<MarketDetails>,
    /// fee_create_ask_flat is the flat fee charged for creating an ask order.
    /// Each coin entry is a separate option. When an ask is created, one of these must be paid.
    /// If empty, no fee is required to create an ask order.
    #[prost(message, repeated, tag = "3")]
    pub fee_create_ask_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_create_bid_flat is the flat fee charged for creating a bid order.
    /// Each coin entry is a separate option. When a bid is created, one of these must be paid.
    /// If empty, no fee is required to create a bid order.
    #[prost(message, repeated, tag = "4")]
    pub fee_create_bid_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_seller_settlement_flat is the flat fee charged to the seller during settlement.
    /// Each coin entry is a separate option.
    /// When an ask is settled, the seller will pay the amount in the denom that matches the price they received.
    #[prost(message, repeated, tag = "5")]
    pub fee_seller_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.
    /// The price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed.
    #[prost(message, repeated, tag = "6")]
    pub fee_seller_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.
    /// Each coin entry is a separate option.
    /// When a bid is created, the settlement fees provided must contain one of these.
    #[prost(message, repeated, tag = "7")]
    pub fee_buyer_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.
    /// The price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but
    /// each price denom to fee denom pair can only have one entry.
    #[prost(message, repeated, tag = "8")]
    pub fee_buyer_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// accepting_orders is whether this market is allowing orders to be created for it.
    #[prost(bool, tag = "9")]
    pub accepting_orders: bool,
    /// allow_user_settlement is whether this market allows users to initiate their own settlements.
    /// For example, the FillBids and FillAsks endpoints are available if and only if this is true.
    /// The MarketSettle endpoint is only available to market actors regardless of the value of this field.
    #[prost(bool, tag = "10")]
    pub allow_user_settlement: bool,
    /// access_grants is the list of addresses and permissions granted for this market.
    #[prost(message, repeated, tag = "11")]
    pub access_grants: ::prost::alloc::vec::Vec<AccessGrant>,
    /// req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.
    /// An account must have all of these attributes in order to create an ask order in this market.
    /// If the list is empty, any account can create ask orders in this market.
    ///
    /// An entry that starts with "*." will match any attributes that end with the rest of it.
    /// E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "b.x.a", or "c.b.a.x".
    #[prost(string, repeated, tag = "12")]
    pub req_attr_create_ask: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.
    /// An account must have all of these attributes in order to create a bid order in this market.
    /// If the list is empty, any account can create bid orders in this market.
    ///
    /// An entry that starts with "*." will match any attributes that end with the rest of it.
    /// E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "c.b.x.a", or "c.b.a.x".
    #[prost(string, repeated, tag = "13")]
    pub req_attr_create_bid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// accepting_commitments is whether the market is allowing users to commit funds to it.
    #[prost(bool, tag = "14")]
    pub accepting_commitments: bool,
    /// fee_create_commitment_flat is the flat fee charged for creating a commitment.
    /// Each coin entry is a separate option. When a commitment is created, one of these must be paid.
    /// If empty, no fee is required to create a commitment.
    #[prost(message, repeated, tag = "15")]
    pub fee_create_commitment_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.
    /// It is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.
    /// During a commitment settlement, the inputs are summed and NAVs are used to convert that total to the
    /// intermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount
    /// that will be transferred out of the market's account into the exchange for that settlement.
    ///
    /// Summing the inputs effectively doubles the value of the settlement from what what is usually thought of
    /// as the value of a trade. That should be taken into account when setting this value.
    /// E.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes
    /// (which might then be converted to USD then nhash before applying this ratio); Usually, though, the value
    /// of that trade would be viewed as either just 10apples or just 100grapes.
    #[prost(uint32, tag = "16")]
    pub commitment_settlement_bips: u32,
    /// intermediary_denom is the denom that funds get converted to (before being converted to the chain's fee denom)
    /// when calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail
    /// if a NAV is needed but not available.
    #[prost(string, tag = "17")]
    pub intermediary_denom: ::prost::alloc::string::String,
    /// req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a
    /// commitment. An account must have all of these attributes in order to create a commitment in this market.
    /// If the list is empty, any account can create commitments in this market.
    ///
    /// An entry that starts with "*." will match any attributes that end with the rest of it.
    /// E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "c.b.x.a", or "c.b.a.x".
    #[prost(string, repeated, tag = "18")]
    pub req_attr_create_commitment: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// FeeRatio defines a ratio of price amount to fee amount.
/// For an order to be valid, its price must be evenly divisible by a FeeRatio's price.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeeRatio {
    /// price is the unit the order price is divided by to get how much of the fee should apply.
    #[prost(message, optional, tag = "1")]
    pub price: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee is the amount to charge per price unit.
    #[prost(message, optional, tag = "2")]
    pub fee: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// AddrPermissions associates an address with a list of permissions available for that address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessGrant {
    /// address is the address that these permissions apply to.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// allowed is the list of permissions available for the address.
    #[prost(enumeration = "Permission", repeated, tag = "2")]
    pub permissions: ::prost::alloc::vec::Vec<i32>,
}
/// Permission defines the different types of permission that can be given to an account for a market.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Permission {
    /// PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.
    Unspecified = 0,
    /// PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.
    Settle = 1,
    /// PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.
    SetIds = 2,
    /// PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.
    Cancel = 3,
    /// PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.
    Withdraw = 4,
    /// PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.
    Update = 5,
    /// PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.
    Permissions = 6,
    /// PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint.
    Attributes = 7,
}
impl Permission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PERMISSION_UNSPECIFIED",
            Self::Settle => "PERMISSION_SETTLE",
            Self::SetIds => "PERMISSION_SET_IDS",
            Self::Cancel => "PERMISSION_CANCEL",
            Self::Withdraw => "PERMISSION_WITHDRAW",
            Self::Update => "PERMISSION_UPDATE",
            Self::Permissions => "PERMISSION_PERMISSIONS",
            Self::Attributes => "PERMISSION_ATTRIBUTES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_SETTLE" => Some(Self::Settle),
            "PERMISSION_SET_IDS" => Some(Self::SetIds),
            "PERMISSION_CANCEL" => Some(Self::Cancel),
            "PERMISSION_WITHDRAW" => Some(Self::Withdraw),
            "PERMISSION_UPDATE" => Some(Self::Update),
            "PERMISSION_PERMISSIONS" => Some(Self::Permissions),
            "PERMISSION_ATTRIBUTES" => Some(Self::Attributes),
            _ => None,
        }
    }
}
/// EventOrderCreated is an event emitted when an order is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOrderCreated {
    /// order_id is the numerical identifier of the order created.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// order_type is the type of order, e.g. "ask" or "bid".
    #[prost(string, tag = "2")]
    pub order_type: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "3")]
    pub market_id: u32,
    /// external_id is the order's external id.
    #[prost(string, tag = "4")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventOrderCancelled is an event emitted when an order is cancelled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOrderCancelled {
    /// order_id is the numerical identifier of the order cancelled.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// cancelled_by is the account that triggered the cancellation of the order.
    #[prost(string, tag = "2")]
    pub cancelled_by: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "3")]
    pub market_id: u32,
    /// external_id is the order's external id.
    #[prost(string, tag = "4")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventOrderFilled is an event emitted when an order has been filled in full.
/// This event is also used for orders that were previously partially filled, but have now been filled in full.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOrderFilled {
    /// order_id is the numerical identifier of the order filled.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// assets is the coins amount string of assets bought/sold for this order.
    #[prost(string, tag = "2")]
    pub assets: ::prost::alloc::string::String,
    /// price is the coins amount string of the price payed/received for this order.
    #[prost(string, tag = "3")]
    pub price: ::prost::alloc::string::String,
    /// fees is the coins amount string of settlement fees paid with this order.
    #[prost(string, tag = "4")]
    pub fees: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "5")]
    pub market_id: u32,
    /// external_id is the order's external id.
    #[prost(string, tag = "6")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventOrderPartiallyFilled is an event emitted when an order filled in part and still has more left to fill.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOrderPartiallyFilled {
    /// order_id is the numerical identifier of the order partially filled.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// assets is the coins amount string of assets that were filled and removed from the order.
    #[prost(string, tag = "2")]
    pub assets: ::prost::alloc::string::String,
    /// price is the coins amount string of the price payed/received for this order.
    /// For ask orders, this might be more than the amount that was removed from the order's price.
    #[prost(string, tag = "3")]
    pub price: ::prost::alloc::string::String,
    /// fees is the coins amount string of settlement fees paid with this partial order.
    /// For ask orders, this might be more than the amount that was removed from the order's settlement fees.
    #[prost(string, tag = "4")]
    pub fees: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "5")]
    pub market_id: u32,
    /// external_id is the order's external id.
    #[prost(string, tag = "6")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventOrderExternalIDUpdated is an event emitted when an order's external id is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOrderExternalIdUpdated {
    /// order_id is the numerical identifier of the order partially filled.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// external_id is the order's new external id.
    #[prost(string, tag = "3")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventFundsCommitted is an event emitted when funds are committed to a market.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventFundsCommitted {
    /// account is the bech32 address string of the account.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// amount is the coins string of the newly committed funds.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// tag is the string provided in the message causing this event.
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
}
/// EventCommitmentReleased is an event emitted when funds are released from their commitment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCommitmentReleased {
    /// account is the bech32 address string of the account.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// amount is the coins string of the funds that were released from commitment.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// tag is the string provided in the message causing this event.
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
}
/// EventMarketWithdraw is an event emitted when a withdrawal of a market's collected fees is made.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketWithdraw {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// amount is the coins amount string of funds withdrawn from the market account.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// destination is the account that received the funds.
    #[prost(string, tag = "3")]
    pub destination: ::prost::alloc::string::String,
    /// withdrawn_by is the account that requested the withdrawal.
    #[prost(string, tag = "4")]
    pub withdrawn_by: ::prost::alloc::string::String,
}
/// EventMarketDetailsUpdated is an event emitted when a market's details are updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketDetailsUpdated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the details.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketEnabled is an event emitted when a market is enabled.
/// Deprecated: This event is no longer used. It is replaced with EventMarketOrdersEnabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketEnabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that enabled the market.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketDisabled is an event emitted when a market is disabled.
/// Deprecated: This event is no longer used. It is replaced with EventMarketOrdersDisabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketDisabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that disabled the market.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketOrdersEnabled is an event emitted when a market enables order creation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketOrdersEnabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the accepting_orders option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketOrdersEnabled is an event emitted when a market disables order creation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketOrdersDisabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the accepting_orders option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketUserSettleEnabled is an event emitted when a market's user_settle option is enabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketUserSettleEnabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the user_settle option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketUserSettleDisabled is an event emitted when a market's user_settle option is disabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketUserSettleDisabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the user_settle option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketCommitmentsEnabled is an event emitted when a market's accepting_commitments option is enabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketCommitmentsEnabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the accepting_commitments option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketCommitmentsDisabled is an event emitted when a market's accepting_commitments option is disabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketCommitmentsDisabled {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the accepting_commitments option.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketIntermediaryDenomUpdated is an event emitted when a market updates its
/// commitment_settlement_intermediary_denom field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketIntermediaryDenomUpdated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the intermediary denom.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketPermissionsUpdated is an event emitted when a market's permissions are updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketPermissionsUpdated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the permissions.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketReqAttrUpdated is an event emitted when a market's required attributes are updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMarketReqAttrUpdated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// updated_by is the account that updated the required attributes.
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
}
/// EventMarketCreated is an event emitted when a market has been created.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventMarketCreated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
}
/// EventMarketFeesUpdated is an event emitted when a market's fees have been updated.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventMarketFeesUpdated {
    /// market_id is the numerical identifier of the market.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
}
/// EventParamsUpdated is an event emitted when the exchange module's params have been updated.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventParamsUpdated {}
/// EventPaymentCreated is an event emitted when a payment is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPaymentCreated {
    /// source is the account that created the Payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// source_amount is the coins amount string of the funds that the source will pay (to the target).
    #[prost(string, tag = "2")]
    pub source_amount: ::prost::alloc::string::String,
    /// target is the account that can accept the Payment.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// target_amount is the coins amount string of the funds that the target will pay (to the source).
    #[prost(string, tag = "4")]
    pub target_amount: ::prost::alloc::string::String,
    /// external_id is used along with the source to uniquely identify this Payment.
    #[prost(string, tag = "5")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventPaymentUpdated is an event emitted when a payment is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPaymentUpdated {
    /// source is the account that updated (and previously created) the Payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// source_amount is the coins amount string of the funds that the source will pay (to the target).
    #[prost(string, tag = "2")]
    pub source_amount: ::prost::alloc::string::String,
    /// old_target is the account that used to be able to accept the Payment (but not any more).
    #[prost(string, tag = "3")]
    pub old_target: ::prost::alloc::string::String,
    /// new_target is the account that is now able to accept the Payment.
    #[prost(string, tag = "4")]
    pub new_target: ::prost::alloc::string::String,
    /// target_amount is the coins amount string of the funds that the target will pay (to the source).
    #[prost(string, tag = "5")]
    pub target_amount: ::prost::alloc::string::String,
    /// external_id is used along with the source to uniquely identify this Payment.
    #[prost(string, tag = "6")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventPaymentAccepted is an event emitted when a payment is accepted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPaymentAccepted {
    /// source is the account that created the Payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// source_amount is the coins amount string of the funds that the source will pay (to the target).
    #[prost(string, tag = "2")]
    pub source_amount: ::prost::alloc::string::String,
    /// target is the account that accepted the Payment.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// target_amount is the coins amount string of the funds that the target will pay (to the source).
    #[prost(string, tag = "4")]
    pub target_amount: ::prost::alloc::string::String,
    /// external_id is used along with the source to uniquely identify this Payment.
    #[prost(string, tag = "5")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventPaymentRejected is an event emitted when a payment is rejected (by the target).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPaymentRejected {
    /// source is the account that created the Payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// target is the account that rejected the Payment.
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    /// external_id is used along with the source to uniquely identify this Payment.
    #[prost(string, tag = "3")]
    pub external_id: ::prost::alloc::string::String,
}
/// EventPaymentCancelled is an event emitted when a payment is cancelled (by the source).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPaymentCancelled {
    /// source is the account that cancelled (and created) the Payment.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// target is the account that could have accepted the Payment.
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    /// external_id is used along with the source to uniquely identify this Payment.
    #[prost(string, tag = "3")]
    pub external_id: ::prost::alloc::string::String,
}
/// Commitment contains information on committed funds.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Commitment {
    /// account is the bech32 address string with the committed funds.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// market_id is the numeric identifier of the market the funds are committed to.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// amount is the funds that have been committed by the account to the market.
    #[prost(message, repeated, tag = "3")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// AccountAmount associates an account with a coins amount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountAmount {
    /// account is the bech32 address string of the account associated with the amount.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// amount is the funds associated with the address.
    #[prost(message, repeated, tag = "2")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MarketAmount associates a market with a coins amount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketAmount {
    /// market_id is the numeric identifier the amount has been committed to.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// amount is the funds associated with the address.
    #[prost(message, repeated, tag = "2")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// NetAssetPrice is an association of assets and price used to record the value of things.
/// It is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as "a NAV".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetAssetPrice {
    /// assets is the volume and denom that has been bought or sold.
    #[prost(message, optional, tag = "1")]
    pub assets: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// price is what was paid for the assets.
    #[prost(message, optional, tag = "2")]
    pub price: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// Order associates an order id with one of the order types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    /// order_id is the numerical identifier for this order.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
    /// order is the specifics of this order.
    #[prost(oneof = "order::Order", tags = "2, 3")]
    pub order: ::core::option::Option<order::Order>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    /// order is the specifics of this order.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Order {
        /// ask_order is the information about this order if it represents an ask order.
        #[prost(message, tag = "2")]
        AskOrder(super::AskOrder),
        /// bid_order is the information about this order if it represents a bid order.
        #[prost(message, tag = "3")]
        BidOrder(super::BidOrder),
    }
}
/// AskOrder represents someone's desire to sell something at a minimum price.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AskOrder {
    /// market_id identifies the market that this order belongs to.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// seller is the address of the account that owns this order and has the assets to sell.
    #[prost(string, tag = "2")]
    pub seller: ::prost::alloc::string::String,
    /// assets are the things that the seller wishes to sell.
    /// A hold is placed on this until the order is filled or cancelled.
    #[prost(message, optional, tag = "3")]
    pub assets: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// price is the minimum amount that the seller is willing to accept for the assets. The seller's settlement
    /// proportional fee (and possibly the settlement flat fee) is taken out of the amount the seller receives,
    /// so it's possible that the seller will still receive less than this price.
    #[prost(message, optional, tag = "4")]
    pub price: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// seller_settlement_flat_fee is the flat fee for sellers that will be charged during settlement. If this denom is the
    /// same denom as the price, it will come out of the actual price received. If this denom is different, the amount must
    /// be in the seller's account and a hold is placed on it until the order is filled or cancelled.
    #[prost(message, optional, tag = "5")]
    pub seller_settlement_flat_fee:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the
    /// order must be either filled in full or not filled at all.
    #[prost(bool, tag = "6")]
    pub allow_partial: bool,
    /// external_id is an optional string used to externally identify this order. Max length is 100 characters.
    /// If an order in this market with this external id already exists, this order will be rejected.
    #[prost(string, tag = "7")]
    pub external_id: ::prost::alloc::string::String,
}
/// BidOrder represents someone's desire to buy something at a specific price.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidOrder {
    /// market_id identifies the market that this order belongs to.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// buyer is the address of the account that owns this order and has the price to spend.
    #[prost(string, tag = "2")]
    pub buyer: ::prost::alloc::string::String,
    /// assets are the things that the buyer wishes to buy.
    #[prost(message, optional, tag = "3")]
    pub assets: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// price is the amount that the buyer will pay for the assets.
    /// A hold is placed on this until the order is filled or cancelled.
    #[prost(message, optional, tag = "4")]
    pub price: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)
    /// when the order is settled. A hold is placed on this until the order is filled or cancelled.
    #[prost(message, repeated, tag = "5")]
    pub buyer_settlement_fees:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the
    /// order must be either filled in full or not filled at all.
    #[prost(bool, tag = "6")]
    pub allow_partial: bool,
    /// external_id is an optional string used to externally identify this order. Max length is 100 characters.
    /// If an order in this market with this external id already exists, this order will be rejected.
    #[prost(string, tag = "7")]
    pub external_id: ::prost::alloc::string::String,
}
/// Params is a representation of the exchange module parameters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    /// default_split is the default proportion of fees the exchange receives in basis points.
    /// It is used if there isn't an applicable denom-specific split defined.
    /// E.g. 100 = 1%. Min = 0, Max = 10000.
    #[prost(uint32, tag = "1")]
    pub default_split: u32,
    /// denom_splits are the denom-specific amounts the exchange receives.
    #[prost(message, repeated, tag = "2")]
    pub denom_splits: ::prost::alloc::vec::Vec<DenomSplit>,
    /// fee_create_payment_flat is the flat fee options for creating a payment.
    /// If the source amount is not zero then one of these fee entries is required to create the payment.
    /// This field is currently limited to zero or one entries.
    #[prost(message, repeated, tag = "3")]
    pub fee_create_payment_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_accept_payment_flat is the flat fee options for accepting a payment.
    /// If the target amount is not zero then one of these fee entries is required to accept the payment.
    /// This field is currently limited to zero or one entries.
    #[prost(message, repeated, tag = "4")]
    pub fee_accept_payment_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// DenomSplit associates a coin denomination with an amount the exchange receives for that denom.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DenomSplit {
    /// denom is the coin denomination this split applies to.
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
    /// split is the proportion of fees the exchange receives for this denom in basis points.
    /// E.g. 100 = 1%. Min = 0, Max = 10000.
    #[prost(uint32, tag = "2")]
    pub split: u32,
}
/// MsgCreateAskRequest is a request message for the CreateAsk endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateAskRequest {
    /// ask_order is the details of the order being created.
    #[prost(message, optional, tag = "1")]
    pub ask_order: ::core::option::Option<AskOrder>,
    /// order_creation_fee is the fee that is being paid to create this order.
    #[prost(message, optional, tag = "2")]
    pub order_creation_fee: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgCreateAskResponse is a response message for the CreateAsk endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreateAskResponse {
    /// order_id is the id of the order created.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
}
/// MsgCreateBidRequest is a request message for the CreateBid endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateBidRequest {
    /// bid_order is the details of the order being created.
    #[prost(message, optional, tag = "1")]
    pub bid_order: ::core::option::Option<BidOrder>,
    /// order_creation_fee is the fee that is being paid to create this order.
    #[prost(message, optional, tag = "2")]
    pub order_creation_fee: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgCreateBidResponse is a response message for the CreateBid endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreateBidResponse {
    /// order_id is the id of the order created.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
}
/// MsgCommitFundsRequest is a request message for the CommitFunds endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCommitFundsRequest {
    /// account is the address of the account with the funds being committed.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market the funds will be committed to.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// amount is the funds being committed to the market.
    #[prost(message, repeated, tag = "3")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// creation_fee is the fee that is being paid to create this commitment.
    #[prost(message, optional, tag = "4")]
    pub creation_fee: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// event_tag is a string that is included in the funds-committed event. Max length is 100 characters.
    #[prost(string, tag = "5")]
    pub event_tag: ::prost::alloc::string::String,
}
/// MsgCommitFundsResponse is a response message for the CommitFunds endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCommitFundsResponse {}
/// MsgCancelOrderRequest is a request message for the CancelOrder endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCancelOrderRequest {
    /// signer is the account requesting the order cancellation.
    /// It must be either the order owner (e.g. the buyer or seller), the governance module account address, or an account
    /// with cancel permission with the market that the order is in.
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    /// order_id is the id of the order to cancel.
    #[prost(uint64, tag = "2")]
    pub order_id: u64,
}
/// MsgCancelOrderResponse is a response message for the CancelOrder endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCancelOrderResponse {}
/// MsgFillBidsRequest is a request message for the FillBids endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgFillBidsRequest {
    /// seller is the address of the account with the assets to sell.
    #[prost(string, tag = "1")]
    pub seller: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market with the bids to fill.
    /// All bid orders being filled must be in this market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// total_assets are the things that the seller wishes to sell.
    /// It must be the sum of all bid order assets.
    #[prost(message, repeated, tag = "3")]
    pub total_assets: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// bid_order_ids are the ids of the bid orders that you are trying to fill.
    /// All ids must be for bid orders, and must be in the same market as the market_id.
    #[prost(uint64, repeated, tag = "4")]
    pub bid_order_ids: ::prost::alloc::vec::Vec<u64>,
    /// seller_settlement_flat_fee is the flat fee for sellers that will be charged for this settlement.
    #[prost(message, optional, tag = "5")]
    pub seller_settlement_flat_fee:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// ask_order_creation_fee is the fee that is being paid to create this order (which is immediately then settled).
    #[prost(message, optional, tag = "6")]
    pub ask_order_creation_fee:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgFillBidsResponse is a response message for the FillBids endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgFillBidsResponse {}
/// MsgFillAsksRequest is a request message for the FillAsks endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgFillAsksRequest {
    /// buyer is the address of the account attempting to buy some assets.
    #[prost(string, tag = "1")]
    pub buyer: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market with the asks to fill.
    /// All ask orders being filled must be in this market.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// total_price is the total amount being spent on some assets.
    /// It must be the sum of all ask order prices.
    #[prost(message, optional, tag = "3")]
    pub total_price: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// ask_order_ids are the ids of the ask orders that you are trying to fill.
    /// All ids must be for ask orders, and must be in the same market as the market_id.
    #[prost(uint64, repeated, tag = "4")]
    pub ask_order_ids: ::prost::alloc::vec::Vec<u64>,
    /// buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)
    /// for this settlement.
    #[prost(message, repeated, tag = "5")]
    pub buyer_settlement_fees:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// bid_order_creation_fee is the fee that is being paid to create this order (which is immediately then settled).
    #[prost(message, optional, tag = "6")]
    pub bid_order_creation_fee:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgFillAsksResponse is a response message for the FillAsks endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgFillAsksResponse {}
/// MsgMarketSettleRequest is a request message for the MarketSettle endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketSettleRequest {
    /// admin is the account with "settle" permission requesting this settlement.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market requesting this settlement.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// ask_order_ids are the ask orders being filled.
    #[prost(uint64, repeated, tag = "3")]
    pub ask_order_ids: ::prost::alloc::vec::Vec<u64>,
    /// bid_order_ids are the bid orders being filled.
    #[prost(uint64, repeated, tag = "4")]
    pub bid_order_ids: ::prost::alloc::vec::Vec<u64>,
    /// expect_partial is whether to expect an order to only be partially filled. Set to true to indicate that either
    /// the last ask order, or last bid order will be partially filled by this settlement. Set to false to indicate
    /// that all provided orders will be filled in full during this settlement.
    #[prost(bool, tag = "5")]
    pub expect_partial: bool,
}
/// MsgMarketSettleResponse is a response message for the MarketSettle endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketSettleResponse {}
/// MsgMarketCommitmentSettleRequest is a request message for the MarketCommitmentSettle endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketCommitmentSettleRequest {
    /// admin is the account with "settle" permission requesting this settlement.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market requesting this settlement.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// inputs defines where the funds are coming from. All of these funds must be already committed to the market.
    #[prost(message, repeated, tag = "3")]
    pub inputs: ::prost::alloc::vec::Vec<AccountAmount>,
    /// outputs defines how the funds are to be distributed. These funds will be re-committed in the destination accounts.
    #[prost(message, repeated, tag = "4")]
    pub outputs: ::prost::alloc::vec::Vec<AccountAmount>,
    /// fees is the funds that the market is collecting as part of this settlement.
    /// All of these funds must be already committed to the market.
    #[prost(message, repeated, tag = "5")]
    pub fees: ::prost::alloc::vec::Vec<AccountAmount>,
    /// navs are any NAV info that should be updated at the beginning of this settlement.
    #[prost(message, repeated, tag = "6")]
    pub navs: ::prost::alloc::vec::Vec<NetAssetPrice>,
    /// event_tag is a string that is included in the funds-committed/released events. Max length is 100 characters.
    #[prost(string, tag = "7")]
    pub event_tag: ::prost::alloc::string::String,
}
/// MsgMarketCommitmentSettleResponse is a response message for the MarketCommitmentSettle endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketCommitmentSettleResponse {}
/// MsgMarketReleaseCommitmentsRequest is a request message for the MarketReleaseCommitments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketReleaseCommitmentsRequest {
    /// admin is the account with "cancel" permission requesting this release.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market releasing these funds.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// to_release is the funds that are to be released.
    /// An entry with a zero amount indicates that all committed funds for that account should be released.
    #[prost(message, repeated, tag = "3")]
    pub to_release: ::prost::alloc::vec::Vec<AccountAmount>,
    /// event_tag is a string that is included in the funds-released events. Max length is 100 characters.
    #[prost(string, tag = "4")]
    pub event_tag: ::prost::alloc::string::String,
}
/// MsgMarketReleaseCommitmentsResponse is a response message for the MarketReleaseCommitments endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketReleaseCommitmentsResponse {}
/// MsgMarketTransferCommitmentRequest is a request message for the MarketTransferCommitment endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketTransferCommitmentRequest {
    /// admin is the account with "cancel" permission requesting this transfer.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// account is the Bech32 address string of the account receiving the transferred funds.
    #[prost(string, tag = "2")]
    pub account: ::prost::alloc::string::String,
    /// amount to transfer.
    #[prost(message, repeated, tag = "3")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// current_market_id is the numerical identifier of the market where the funds are currently committed and are being
    /// released from.
    #[prost(uint32, tag = "4")]
    pub current_market_id: u32,
    /// new_market_id is the numerical identifier of the market that is receiving the funds as part of the settlement.
    #[prost(uint32, tag = "5")]
    pub new_market_id: u32,
    /// event_tag is a string that is included in the funds-released events. Max length is 100 characters.
    #[prost(string, tag = "6")]
    pub event_tag: ::prost::alloc::string::String,
}
/// MsgMarketTransferCommitmentResponse is a response message for the MarketTransferCommitment endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketTransferCommitmentResponse {}
/// MsgMarketSetOrderExternalIDRequest is a request message for the MarketSetOrderExternalID endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketSetOrderExternalIdRequest {
    /// admin is the account with "set_ids" permission requesting this settlement.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market with the orders to update.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// order_id is the numerical identifier of the order to update.
    #[prost(uint64, tag = "3")]
    pub order_id: u64,
    /// external_id is the new external id to associate with the order. Max length is 100 characters.
    /// If the external id is already associated with another order in this market, this update will fail.
    #[prost(string, tag = "4")]
    pub external_id: ::prost::alloc::string::String,
}
/// MsgMarketSetOrderExternalIDResponse is a response message for the MarketSetOrderExternalID endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketSetOrderExternalIdResponse {}
/// MsgMarketWithdrawRequest is a request message for the MarketWithdraw endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketWithdrawRequest {
    /// admin is the account with withdraw permission requesting the withdrawal.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to withdraw from.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// to_address is the address that will receive the funds.
    #[prost(string, tag = "3")]
    pub to_address: ::prost::alloc::string::String,
    /// amount is the funds to withdraw.
    #[prost(message, repeated, tag = "4")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgMarketWithdrawResponse is a response message for the MarketWithdraw endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketWithdrawResponse {}
/// MsgMarketUpdateDetailsRequest is a request message for the MarketUpdateDetails endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateDetailsRequest {
    /// admin is the account with "update" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to update details for.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// market_details is some information about this market.
    #[prost(message, optional, tag = "3")]
    pub market_details: ::core::option::Option<MarketDetails>,
}
/// MsgMarketUpdateDetailsResponse is a response message for the MarketUpdateDetails endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateDetailsResponse {}
/// MsgMarketUpdateEnabledRequest is a request message for the MarketUpdateEnabled endpoint.
/// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateEnabledRequest {
    /// admin is the account with "update" permission requesting this change.
    /// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to enable or disable.
    /// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
    #[deprecated]
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// accepting_orders is whether this market is allowing orders to be created for it.
    /// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub accepting_orders: bool,
}
/// MsgMarketUpdateEnabledResponse is a response message for the MarketUpdateEnabled endpoint.
/// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateEnabledResponse {}
/// MsgMarketUpdateAcceptingOrdersRequest is a request message for the MarketUpdateAcceptingOrders endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateAcceptingOrdersRequest {
    /// admin is the account with "update" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to enable or disable.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// accepting_orders is whether this market is allowing orders to be created for it.
    #[prost(bool, tag = "3")]
    pub accepting_orders: bool,
}
/// MsgMarketUpdateAcceptingOrdersResponse is a response message for the MarketUpdateAcceptingOrders endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateAcceptingOrdersResponse {}
/// MsgMarketUpdateUserSettleRequest is a request message for the MarketUpdateUserSettle endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateUserSettleRequest {
    /// admin is the account with "update" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to enable or disable user-settlement for.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// allow_user_settlement is whether this market allows users to initiate their own settlements.
    /// For example, the FillBids and FillAsks endpoints are available if and only if this is true.
    /// The MarketSettle endpoint is available (only to market actors) regardless of the value of this field.
    #[prost(bool, tag = "3")]
    pub allow_user_settlement: bool,
}
/// MsgMarketUpdateUserSettleResponse is a response message for the MarketUpdateUserSettle endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateUserSettleResponse {}
/// MsgMarketUpdateAcceptingCommitmentsRequest is a request message for the MarketUpdateAcceptingCommitments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateAcceptingCommitmentsRequest {
    /// admin is the account with "update" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to enable or disable commitments for.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// accepting_commitments is whether this market allows users to commit funds to it.
    /// For example, the CommitFunds endpoint is available if and only if this is true.
    /// The MarketCommitmentSettle endpoint is available (only to market actors) regardless of the value of this field.
    #[prost(bool, tag = "3")]
    pub accepting_commitments: bool,
}
/// MsgMarketUpdateAcceptingCommitmentsResponse is a response message for the MarketUpdateAcceptingCommitments endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateAcceptingCommitmentsResponse {}
/// MsgMarketUpdateIntermediaryDenomRequest is a request message for the MarketUpdateIntermediaryDenom endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateIntermediaryDenomRequest {
    /// admin is the account with "update" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market changing the intermediary denom.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// intermediary_denom is the new intermediary denom for this market to use.
    #[prost(string, tag = "3")]
    pub intermediary_denom: ::prost::alloc::string::String,
}
/// MsgMarketUpdateIntermediaryDenomResponse is a response message for the MarketUpdateIntermediaryDenom endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketUpdateIntermediaryDenomResponse {}
/// MsgMarketManagePermissionsRequest is a request message for the MarketManagePermissions endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketManagePermissionsRequest {
    /// admin is the account with "permissions" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to manage permissions for.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// revoke_all are addresses that should have all their permissions revoked.
    #[prost(string, repeated, tag = "3")]
    pub revoke_all: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// to_revoke are the specific permissions to remove for addresses.
    #[prost(message, repeated, tag = "4")]
    pub to_revoke: ::prost::alloc::vec::Vec<AccessGrant>,
    /// to_grant are the permissions to grant to addresses.
    #[prost(message, repeated, tag = "5")]
    pub to_grant: ::prost::alloc::vec::Vec<AccessGrant>,
}
/// MsgMarketManagePermissionsResponse is a response message for the MarketManagePermissions endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketManagePermissionsResponse {}
/// MsgMarketManageReqAttrsRequest is a request message for the MarketManageReqAttrs endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMarketManageReqAttrsRequest {
    /// admin is the account with "attributes" permission requesting this change.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to update required attributes for.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// create_ask_to_add are the attributes that should now also be required to create an ask order.
    #[prost(string, repeated, tag = "3")]
    pub create_ask_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// create_ask_to_remove are the attributes that should no longer be required to create an ask order.
    #[prost(string, repeated, tag = "4")]
    pub create_ask_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// create_bid_to_add are the attributes that should now also be required to create a bid order.
    #[prost(string, repeated, tag = "5")]
    pub create_bid_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// create_bid_to_remove are the attributes that should no longer be required to create a bid order.
    #[prost(string, repeated, tag = "6")]
    pub create_bid_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// create_commitment_to_add are the attributes that should now also be required to create a commitment.
    #[prost(string, repeated, tag = "7")]
    pub create_commitment_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// create_commitment_to_remove are the attributes that should no longer be required to create a commitment.
    #[prost(string, repeated, tag = "8")]
    pub create_commitment_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MsgMarketManageReqAttrsResponse is a response message for the MarketManageReqAttrs endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMarketManageReqAttrsResponse {}
/// MsgCreatePaymentRequest is a request message for the CreatePayment endpoint.
///
/// The signer is the payment.source, but we can't define that using the cosmos.msg.v1.signer option.
/// So signers for this msg are defined in code using a custom get-signers function.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreatePaymentRequest {
    /// payment is the details of the payment to create.
    #[prost(message, optional, tag = "1")]
    pub payment: ::core::option::Option<Payment>,
}
/// MsgCreatePaymentResponse is a response message for the CreatePayment endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreatePaymentResponse {}
/// MsgAcceptPaymentRequest is a request message for the AcceptPayment endpoint.
///
/// The signer is the payment.target, but we can't define that using the cosmos.msg.v1.signer option.
/// So signers for this msg are defined in code using a custom get-signers function.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAcceptPaymentRequest {
    /// payment is the details of the payment to accept.
    #[prost(message, optional, tag = "1")]
    pub payment: ::core::option::Option<Payment>,
}
/// MsgAcceptPaymentResponse is a response message for the AcceptPayment endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAcceptPaymentResponse {}
/// MsgRejectPaymentRequest is a request message for the RejectPayment endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRejectPaymentRequest {
    /// target is the target account of the payment to reject.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// source is the source account of the payment to reject.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// external_id is the external id of the payment to reject.
    #[prost(string, tag = "3")]
    pub external_id: ::prost::alloc::string::String,
}
/// MsgRejectPaymentResponse is a response message for the RejectPayment endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRejectPaymentResponse {}
/// MsgRejectPaymentsRequest is a request message for the RejectPayments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRejectPaymentsRequest {
    /// target is the account that wishes to reject some payments.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// sources is the source accounts of the payments to reject.
    #[prost(string, repeated, tag = "2")]
    pub sources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MsgRejectPaymentsResponse is a response message for the RejectPayments endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRejectPaymentsResponse {}
/// MsgCancelPaymentsRequest is a request message for the CancelPayments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCancelPaymentsRequest {
    /// source is the account that wishes to cancel some of their payments.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// external_ids is all of the external ids of the payments to cancel.
    #[prost(string, repeated, tag = "2")]
    pub external_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MsgCancelPaymentsResponse is a response message for the CancelPayments endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCancelPaymentsResponse {}
/// MsgChangePaymentTargetRequest is a request message for the ChangePaymentTarget endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgChangePaymentTargetRequest {
    /// source is the account that wishes to update the target of one of their payments.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// external_id is the external id of the payment to update.
    #[prost(string, tag = "2")]
    pub external_id: ::prost::alloc::string::String,
    /// new_target is the new target account of the payment.
    #[prost(string, tag = "3")]
    pub new_target: ::prost::alloc::string::String,
}
/// MsgChangePaymentTargetResponse is a response message for the ChangePaymentTarget endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgChangePaymentTargetResponse {}
/// MsgGovCreateMarketRequest is a request message for the GovCreateMarket endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgGovCreateMarketRequest {
    /// authority should be the governance module account address.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// market is the initial market configuration.
    /// If the market_id is 0, the next available market_id will be used (once voting ends).
    /// If it is not zero, it must not yet be in use when the voting period ends.
    #[prost(message, optional, tag = "2")]
    pub market: ::core::option::Option<Market>,
}
/// MsgGovCreateMarketResponse is a response message for the GovCreateMarket endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgGovCreateMarketResponse {}
/// MsgGovManageFeesRequest is a request message for the GovManageFees endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgGovManageFeesRequest {
    /// authority should be the governance module account address.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// market_id is the market id that will get these fee updates.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
    /// add_fee_create_ask_flat are the create-ask flat fee options to add.
    #[prost(message, repeated, tag = "3")]
    pub add_fee_create_ask_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// remove_fee_create_ask_flat are the create-ask flat fee options to remove.
    #[prost(message, repeated, tag = "4")]
    pub remove_fee_create_ask_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// add_fee_create_bid_flat are the create-bid flat fee options to add.
    #[prost(message, repeated, tag = "5")]
    pub add_fee_create_bid_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// remove_fee_create_bid_flat are the create-bid flat fee options to remove.
    #[prost(message, repeated, tag = "6")]
    pub remove_fee_create_bid_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// add_fee_seller_settlement_flat are the seller settlement flat fee options to add.
    #[prost(message, repeated, tag = "7")]
    pub add_fee_seller_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// remove_fee_seller_settlement_flat are the seller settlement flat fee options to remove.
    #[prost(message, repeated, tag = "8")]
    pub remove_fee_seller_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// add_fee_seller_settlement_ratios are the seller settlement fee ratios to add.
    #[prost(message, repeated, tag = "9")]
    pub add_fee_seller_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// remove_fee_seller_settlement_ratios are the seller settlement fee ratios to remove.
    #[prost(message, repeated, tag = "10")]
    pub remove_fee_seller_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// add_fee_buyer_settlement_flat are the buyer settlement flat fee options to add.
    #[prost(message, repeated, tag = "11")]
    pub add_fee_buyer_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// remove_fee_buyer_settlement_flat are the buyer settlement flat fee options to remove.
    #[prost(message, repeated, tag = "12")]
    pub remove_fee_buyer_settlement_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// add_fee_buyer_settlement_ratios are the buyer settlement fee ratios to add.
    #[prost(message, repeated, tag = "13")]
    pub add_fee_buyer_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// remove_fee_buyer_settlement_ratios are the buyer settlement fee ratios to remove.
    #[prost(message, repeated, tag = "14")]
    pub remove_fee_buyer_settlement_ratios: ::prost::alloc::vec::Vec<FeeRatio>,
    /// add_fee_create_commitment_flat are the create-commitment flat fee options to add.
    #[prost(message, repeated, tag = "15")]
    pub add_fee_create_commitment_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// remove_fee_create_commitment_flat are the create-commitment flat fee options to remove.
    #[prost(message, repeated, tag = "16")]
    pub remove_fee_create_commitment_flat:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// set_fee_commitment_settlement_bips is the new fee_commitment_settlement_bips for the market.
    /// It is ignored if it is zero. To set it to zero set unset_fee_commitment_settlement_bips to true.
    #[prost(uint32, tag = "17")]
    pub set_fee_commitment_settlement_bips: u32,
    /// unset_fee_commitment_settlement_bips, if true, sets the fee_commitment_settlement_bips to zero.
    /// If false, it is ignored.
    #[prost(bool, tag = "18")]
    pub unset_fee_commitment_settlement_bips: bool,
}
/// MsgGovManageFeesResponse is a response message for the GovManageFees endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgGovManageFeesResponse {}
/// MsgGovCloseMarketRequest is a request message for the GovCloseMarket endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgGovCloseMarketRequest {
    /// authority must be the governance module account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// market_id is the numerical identifier of the market to close.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
}
/// MsgGovCloseMarketResponse is a response message for the GovCloseMarket endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgGovCloseMarketResponse {}
/// MsgGovUpdateParamsRequest is a request message for the GovUpdateParams endpoint.
/// Deprecated: Use MsgUpdateParamsRequest instead.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgGovUpdateParamsRequest {
    /// authority should be the governance module account address.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// params are the new param values to set
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
/// MsgGovUpdateParamsResponse is a response message for the GovUpdateParams endpoint.
/// Deprecated: Use MsgUpdateParamsResponse instead.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgGovUpdateParamsResponse {}
/// MsgGovUpdateParamsRequest is a request message for the GovUpdateParams endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsRequest {
    /// authority should be the governance module account address.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// params are the new param values to set
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
/// MsgUpdateParamsResponse is a response message for the GovUpdateParams endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
/// Generated client implementations.
#[cfg(feature = "grpc")]
#[cfg_attr(docsrs, doc(cfg(feature = "grpc")))]
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Msg is the service for exchange module's tx endpoints.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "grpc-transport")]
    #[cfg_attr(docsrs, doc(cfg(feature = "grpc-transport")))]
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// CreateAsk creates an ask order (to sell something you own).
        pub async fn create_ask(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateAskRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreateAskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CreateAsk");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "CreateAsk"));
            self.inner.unary(req, path, codec).await
        }
        /// CreateBid creates a bid order (to buy something you want).
        pub async fn create_bid(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateBidRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreateBidResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CreateBid");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "CreateBid"));
            self.inner.unary(req, path, codec).await
        }
        /// CommitFunds marks funds in an account as manageable by a market.
        pub async fn commit_funds(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCommitFundsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCommitFundsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CommitFunds");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "CommitFunds"));
            self.inner.unary(req, path, codec).await
        }
        /// CancelOrder cancels an order.
        pub async fn cancel_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCancelOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCancelOrderResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CancelOrder");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "CancelOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// FillBids uses the assets in your account to fulfill one or more bids (similar to a fill-or-cancel ask).
        pub async fn fill_bids(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgFillBidsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgFillBidsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/FillBids");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "FillBids"));
            self.inner.unary(req, path, codec).await
        }
        /// FillAsks uses the funds in your account to fulfill one or more asks (similar to a fill-or-cancel bid).
        pub async fn fill_asks(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgFillAsksRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgFillAsksResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/FillAsks");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Msg", "FillAsks"));
            self.inner.unary(req, path, codec).await
        }
        /// MarketSettle is a market endpoint to trigger the settlement of orders.
        pub async fn market_settle(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketSettleRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgMarketSettleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/MarketSettle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketSettle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketCommitmentSettle is a market endpoint to transfer committed funds.
        pub async fn market_commitment_settle(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketCommitmentSettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketCommitmentSettleResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketCommitmentSettle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketCommitmentSettle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketReleaseCommitments is a market endpoint return control of funds back to the account owner(s).
        pub async fn market_release_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketReleaseCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketReleaseCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketReleaseCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketReleaseCommitments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketTransferCommitment is a market endpoint to transfers committed funds from one market to another.
        pub async fn market_transfer_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketTransferCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketTransferCommitmentResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketTransferCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketTransferCommitment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketSetOrderExternalID updates an order's external id field.
        pub async fn market_set_order_external_id(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketSetOrderExternalIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketSetOrderExternalIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketSetOrderExternalID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketSetOrderExternalID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketWithdraw is a market endpoint to withdraw fees that have been collected.
        pub async fn market_withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketWithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgMarketWithdrawResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/MarketWithdraw");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketWithdraw",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateDetails is a market endpoint to update its details.
        pub async fn market_update_details(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateEnabled is a market endpoint to update whether its accepting orders.
        /// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
        #[deprecated]
        pub async fn market_update_enabled(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateEnabledRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateEnabledResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateEnabled",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateEnabled",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateAcceptingOrders is a market endpoint to update whether its accepting orders.
        pub async fn market_update_accepting_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateAcceptingOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateAcceptingOrdersResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateAcceptingOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateAcceptingOrders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateUserSettle is a market endpoint to update whether it allows user-initiated settlement.
        pub async fn market_update_user_settle(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateUserSettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateUserSettleResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateUserSettle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateUserSettle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateAcceptingCommitments is a market endpoint to update whether it accepts commitments.
        pub async fn market_update_accepting_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateAcceptingCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateAcceptingCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateAcceptingCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateAcceptingCommitments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketUpdateIntermediaryDenom sets a market's intermediary denom.
        pub async fn market_update_intermediary_denom(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketUpdateIntermediaryDenomRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateIntermediaryDenomResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketUpdateIntermediaryDenom",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketUpdateIntermediaryDenom",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketManagePermissions is a market endpoint to manage a market's user permissions.
        pub async fn market_manage_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketManagePermissionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketManagePermissionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketManagePermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketManagePermissions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// MarketManageReqAttrs is a market endpoint to manage the attributes required to interact with it.
        pub async fn market_manage_req_attrs(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMarketManageReqAttrsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketManageReqAttrsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/MarketManageReqAttrs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "MarketManageReqAttrs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// CreatePayment creates a payment to facilitate a trade between two accounts.
        pub async fn create_payment(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreatePaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreatePaymentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CreatePayment");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "CreatePayment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// AcceptPayment is used by a target to accept a payment.
        pub async fn accept_payment(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAcceptPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgAcceptPaymentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/AcceptPayment");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "AcceptPayment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RejectPayment can be used by a target to reject a payment.
        pub async fn reject_payment(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRejectPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgRejectPaymentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/RejectPayment");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "RejectPayment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RejectPayments can be used by a target to reject all payments from one or more sources.
        pub async fn reject_payments(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRejectPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgRejectPaymentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/RejectPayments");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "RejectPayments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// CancelPayments can be used by a source to cancel one or more payments.
        pub async fn cancel_payments(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCancelPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCancelPaymentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/CancelPayments");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "CancelPayments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ChangePaymentTarget can be used by a source to change the target in one of their payments.
        pub async fn change_payment_target(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgChangePaymentTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgChangePaymentTargetResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Msg/ChangePaymentTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "ChangePaymentTarget",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GovCreateMarket is a governance proposal endpoint for creating a market.
        pub async fn gov_create_market(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgGovCreateMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovCreateMarketResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/GovCreateMarket");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "GovCreateMarket",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GovManageFees is a governance proposal endpoint for updating a market's fees.
        pub async fn gov_manage_fees(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgGovManageFeesRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovManageFeesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/GovManageFees");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "GovManageFees",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GovCloseMarket is a governance proposal endpoint that will disable order and commitment creation,
        /// cancel all orders, and release all commitments.
        pub async fn gov_close_market(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgGovCloseMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovCloseMarketResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/GovCloseMarket");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "GovCloseMarket",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GovUpdateParams is a governance proposal endpoint for updating the exchange module's params.
        /// Deprecated: Use UpdateParams instead.
        #[deprecated]
        pub async fn gov_update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgGovUpdateParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovUpdateParamsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/GovUpdateParams");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "GovUpdateParams",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateParams is a governance proposal endpoint for updating the exchange module's params.
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgUpdateParamsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Msg/UpdateParams");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Msg",
                "UpdateParams",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "grpc")]
#[cfg_attr(docsrs, doc(cfg(feature = "grpc")))]
pub mod msg_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: std::marker::Send + std::marker::Sync + 'static {
        /// CreateAsk creates an ask order (to sell something you own).
        async fn create_ask(
            &self,
            request: tonic::Request<super::MsgCreateAskRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreateAskResponse>, tonic::Status>;
        /// CreateBid creates a bid order (to buy something you want).
        async fn create_bid(
            &self,
            request: tonic::Request<super::MsgCreateBidRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreateBidResponse>, tonic::Status>;
        /// CommitFunds marks funds in an account as manageable by a market.
        async fn commit_funds(
            &self,
            request: tonic::Request<super::MsgCommitFundsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCommitFundsResponse>, tonic::Status>;
        /// CancelOrder cancels an order.
        async fn cancel_order(
            &self,
            request: tonic::Request<super::MsgCancelOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCancelOrderResponse>, tonic::Status>;
        /// FillBids uses the assets in your account to fulfill one or more bids (similar to a fill-or-cancel ask).
        async fn fill_bids(
            &self,
            request: tonic::Request<super::MsgFillBidsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgFillBidsResponse>, tonic::Status>;
        /// FillAsks uses the funds in your account to fulfill one or more asks (similar to a fill-or-cancel bid).
        async fn fill_asks(
            &self,
            request: tonic::Request<super::MsgFillAsksRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgFillAsksResponse>, tonic::Status>;
        /// MarketSettle is a market endpoint to trigger the settlement of orders.
        async fn market_settle(
            &self,
            request: tonic::Request<super::MsgMarketSettleRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgMarketSettleResponse>, tonic::Status>;
        /// MarketCommitmentSettle is a market endpoint to transfer committed funds.
        async fn market_commitment_settle(
            &self,
            request: tonic::Request<super::MsgMarketCommitmentSettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketCommitmentSettleResponse>,
            tonic::Status,
        >;
        /// MarketReleaseCommitments is a market endpoint return control of funds back to the account owner(s).
        async fn market_release_commitments(
            &self,
            request: tonic::Request<super::MsgMarketReleaseCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketReleaseCommitmentsResponse>,
            tonic::Status,
        >;
        /// MarketTransferCommitment is a market endpoint to transfers committed funds from one market to another.
        async fn market_transfer_commitment(
            &self,
            request: tonic::Request<super::MsgMarketTransferCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketTransferCommitmentResponse>,
            tonic::Status,
        >;
        /// MarketSetOrderExternalID updates an order's external id field.
        async fn market_set_order_external_id(
            &self,
            request: tonic::Request<super::MsgMarketSetOrderExternalIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketSetOrderExternalIdResponse>,
            tonic::Status,
        >;
        /// MarketWithdraw is a market endpoint to withdraw fees that have been collected.
        async fn market_withdraw(
            &self,
            request: tonic::Request<super::MsgMarketWithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgMarketWithdrawResponse>, tonic::Status>;
        /// MarketUpdateDetails is a market endpoint to update its details.
        async fn market_update_details(
            &self,
            request: tonic::Request<super::MsgMarketUpdateDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateDetailsResponse>,
            tonic::Status,
        >;
        /// MarketUpdateEnabled is a market endpoint to update whether its accepting orders.
        /// Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
        async fn market_update_enabled(
            &self,
            request: tonic::Request<super::MsgMarketUpdateEnabledRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateEnabledResponse>,
            tonic::Status,
        >;
        /// MarketUpdateAcceptingOrders is a market endpoint to update whether its accepting orders.
        async fn market_update_accepting_orders(
            &self,
            request: tonic::Request<super::MsgMarketUpdateAcceptingOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateAcceptingOrdersResponse>,
            tonic::Status,
        >;
        /// MarketUpdateUserSettle is a market endpoint to update whether it allows user-initiated settlement.
        async fn market_update_user_settle(
            &self,
            request: tonic::Request<super::MsgMarketUpdateUserSettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateUserSettleResponse>,
            tonic::Status,
        >;
        /// MarketUpdateAcceptingCommitments is a market endpoint to update whether it accepts commitments.
        async fn market_update_accepting_commitments(
            &self,
            request: tonic::Request<super::MsgMarketUpdateAcceptingCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateAcceptingCommitmentsResponse>,
            tonic::Status,
        >;
        /// MarketUpdateIntermediaryDenom sets a market's intermediary denom.
        async fn market_update_intermediary_denom(
            &self,
            request: tonic::Request<super::MsgMarketUpdateIntermediaryDenomRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketUpdateIntermediaryDenomResponse>,
            tonic::Status,
        >;
        /// MarketManagePermissions is a market endpoint to manage a market's user permissions.
        async fn market_manage_permissions(
            &self,
            request: tonic::Request<super::MsgMarketManagePermissionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketManagePermissionsResponse>,
            tonic::Status,
        >;
        /// MarketManageReqAttrs is a market endpoint to manage the attributes required to interact with it.
        async fn market_manage_req_attrs(
            &self,
            request: tonic::Request<super::MsgMarketManageReqAttrsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMarketManageReqAttrsResponse>,
            tonic::Status,
        >;
        /// CreatePayment creates a payment to facilitate a trade between two accounts.
        async fn create_payment(
            &self,
            request: tonic::Request<super::MsgCreatePaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCreatePaymentResponse>, tonic::Status>;
        /// AcceptPayment is used by a target to accept a payment.
        async fn accept_payment(
            &self,
            request: tonic::Request<super::MsgAcceptPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgAcceptPaymentResponse>, tonic::Status>;
        /// RejectPayment can be used by a target to reject a payment.
        async fn reject_payment(
            &self,
            request: tonic::Request<super::MsgRejectPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgRejectPaymentResponse>, tonic::Status>;
        /// RejectPayments can be used by a target to reject all payments from one or more sources.
        async fn reject_payments(
            &self,
            request: tonic::Request<super::MsgRejectPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgRejectPaymentsResponse>, tonic::Status>;
        /// CancelPayments can be used by a source to cancel one or more payments.
        async fn cancel_payments(
            &self,
            request: tonic::Request<super::MsgCancelPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgCancelPaymentsResponse>, tonic::Status>;
        /// ChangePaymentTarget can be used by a source to change the target in one of their payments.
        async fn change_payment_target(
            &self,
            request: tonic::Request<super::MsgChangePaymentTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgChangePaymentTargetResponse>,
            tonic::Status,
        >;
        /// GovCreateMarket is a governance proposal endpoint for creating a market.
        async fn gov_create_market(
            &self,
            request: tonic::Request<super::MsgGovCreateMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovCreateMarketResponse>, tonic::Status>;
        /// GovManageFees is a governance proposal endpoint for updating a market's fees.
        async fn gov_manage_fees(
            &self,
            request: tonic::Request<super::MsgGovManageFeesRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovManageFeesResponse>, tonic::Status>;
        /// GovCloseMarket is a governance proposal endpoint that will disable order and commitment creation,
        /// cancel all orders, and release all commitments.
        async fn gov_close_market(
            &self,
            request: tonic::Request<super::MsgGovCloseMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovCloseMarketResponse>, tonic::Status>;
        /// GovUpdateParams is a governance proposal endpoint for updating the exchange module's params.
        /// Deprecated: Use UpdateParams instead.
        async fn gov_update_params(
            &self,
            request: tonic::Request<super::MsgGovUpdateParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgGovUpdateParamsResponse>, tonic::Status>;
        /// UpdateParams is a governance proposal endpoint for updating the exchange module's params.
        async fn update_params(
            &self,
            request: tonic::Request<super::MsgUpdateParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::MsgUpdateParamsResponse>, tonic::Status>;
    }
    /// Msg is the service for exchange module's tx endpoints.
    #[derive(Debug)]
    pub struct MsgServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/provenance.exchange.v1.Msg/CreateAsk" => {
                    #[allow(non_camel_case_types)]
                    struct CreateAskSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCreateAskRequest> for CreateAskSvc<T> {
                        type Response = super::MsgCreateAskResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCreateAskRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Msg>::create_ask(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateAskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/CreateBid" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBidSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCreateBidRequest> for CreateBidSvc<T> {
                        type Response = super::MsgCreateBidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCreateBidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Msg>::create_bid(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateBidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/CommitFunds" => {
                    #[allow(non_camel_case_types)]
                    struct CommitFundsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCommitFundsRequest> for CommitFundsSvc<T> {
                        type Response = super::MsgCommitFundsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCommitFundsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::commit_funds(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CommitFundsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/CancelOrder" => {
                    #[allow(non_camel_case_types)]
                    struct CancelOrderSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCancelOrderRequest> for CancelOrderSvc<T> {
                        type Response = super::MsgCancelOrderResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCancelOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::cancel_order(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/FillBids" => {
                    #[allow(non_camel_case_types)]
                    struct FillBidsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgFillBidsRequest> for FillBidsSvc<T> {
                        type Response = super::MsgFillBidsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgFillBidsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Msg>::fill_bids(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FillBidsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/FillAsks" => {
                    #[allow(non_camel_case_types)]
                    struct FillAsksSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgFillAsksRequest> for FillAsksSvc<T> {
                        type Response = super::MsgFillAsksResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgFillAsksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Msg>::fill_asks(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FillAsksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketSettle" => {
                    #[allow(non_camel_case_types)]
                    struct MarketSettleSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMarketSettleRequest> for MarketSettleSvc<T> {
                        type Response = super::MsgMarketSettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketSettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::market_settle(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketSettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketCommitmentSettle" => {
                    #[allow(non_camel_case_types)]
                    struct MarketCommitmentSettleSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketCommitmentSettleRequest>
                        for MarketCommitmentSettleSvc<T>
                    {
                        type Response = super::MsgMarketCommitmentSettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketCommitmentSettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_commitment_settle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketCommitmentSettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketReleaseCommitments" => {
                    #[allow(non_camel_case_types)]
                    struct MarketReleaseCommitmentsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketReleaseCommitmentsRequest>
                        for MarketReleaseCommitmentsSvc<T>
                    {
                        type Response = super::MsgMarketReleaseCommitmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketReleaseCommitmentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_release_commitments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketReleaseCommitmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketTransferCommitment" => {
                    #[allow(non_camel_case_types)]
                    struct MarketTransferCommitmentSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketTransferCommitmentRequest>
                        for MarketTransferCommitmentSvc<T>
                    {
                        type Response = super::MsgMarketTransferCommitmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketTransferCommitmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_transfer_commitment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketTransferCommitmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketSetOrderExternalID" => {
                    #[allow(non_camel_case_types)]
                    struct MarketSetOrderExternalIDSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketSetOrderExternalIdRequest>
                        for MarketSetOrderExternalIDSvc<T>
                    {
                        type Response = super::MsgMarketSetOrderExternalIdResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketSetOrderExternalIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_set_order_external_id(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketSetOrderExternalIDSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketWithdraw" => {
                    #[allow(non_camel_case_types)]
                    struct MarketWithdrawSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMarketWithdrawRequest> for MarketWithdrawSvc<T> {
                        type Response = super::MsgMarketWithdrawResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketWithdrawRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::market_withdraw(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketWithdrawSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateDetails" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateDetailsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMarketUpdateDetailsRequest>
                        for MarketUpdateDetailsSvc<T>
                    {
                        type Response = super::MsgMarketUpdateDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketUpdateDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateEnabled" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateEnabledSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMarketUpdateEnabledRequest>
                        for MarketUpdateEnabledSvc<T>
                    {
                        type Response = super::MsgMarketUpdateEnabledResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketUpdateEnabledRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_enabled(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateEnabledSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateAcceptingOrders" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateAcceptingOrdersSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketUpdateAcceptingOrdersRequest>
                        for MarketUpdateAcceptingOrdersSvc<T>
                    {
                        type Response = super::MsgMarketUpdateAcceptingOrdersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketUpdateAcceptingOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_accepting_orders(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateAcceptingOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateUserSettle" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateUserSettleSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketUpdateUserSettleRequest>
                        for MarketUpdateUserSettleSvc<T>
                    {
                        type Response = super::MsgMarketUpdateUserSettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketUpdateUserSettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_user_settle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateUserSettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateAcceptingCommitments" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateAcceptingCommitmentsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<
                            super::MsgMarketUpdateAcceptingCommitmentsRequest,
                        > for MarketUpdateAcceptingCommitmentsSvc<T>
                    {
                        type Response = super::MsgMarketUpdateAcceptingCommitmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MsgMarketUpdateAcceptingCommitmentsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_accepting_commitments(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateAcceptingCommitmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketUpdateIntermediaryDenom" => {
                    #[allow(non_camel_case_types)]
                    struct MarketUpdateIntermediaryDenomSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketUpdateIntermediaryDenomRequest>
                        for MarketUpdateIntermediaryDenomSvc<T>
                    {
                        type Response = super::MsgMarketUpdateIntermediaryDenomResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketUpdateIntermediaryDenomRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_update_intermediary_denom(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketUpdateIntermediaryDenomSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketManagePermissions" => {
                    #[allow(non_camel_case_types)]
                    struct MarketManagePermissionsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg>
                        tonic::server::UnaryService<super::MsgMarketManagePermissionsRequest>
                        for MarketManagePermissionsSvc<T>
                    {
                        type Response = super::MsgMarketManagePermissionsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketManagePermissionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_manage_permissions(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketManagePermissionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/MarketManageReqAttrs" => {
                    #[allow(non_camel_case_types)]
                    struct MarketManageReqAttrsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMarketManageReqAttrsRequest>
                        for MarketManageReqAttrsSvc<T>
                    {
                        type Response = super::MsgMarketManageReqAttrsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMarketManageReqAttrsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::market_manage_req_attrs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarketManageReqAttrsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/CreatePayment" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePaymentSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCreatePaymentRequest> for CreatePaymentSvc<T> {
                        type Response = super::MsgCreatePaymentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCreatePaymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::create_payment(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreatePaymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/AcceptPayment" => {
                    #[allow(non_camel_case_types)]
                    struct AcceptPaymentSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgAcceptPaymentRequest> for AcceptPaymentSvc<T> {
                        type Response = super::MsgAcceptPaymentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgAcceptPaymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::accept_payment(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcceptPaymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/RejectPayment" => {
                    #[allow(non_camel_case_types)]
                    struct RejectPaymentSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgRejectPaymentRequest> for RejectPaymentSvc<T> {
                        type Response = super::MsgRejectPaymentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgRejectPaymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::reject_payment(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RejectPaymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/RejectPayments" => {
                    #[allow(non_camel_case_types)]
                    struct RejectPaymentsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgRejectPaymentsRequest> for RejectPaymentsSvc<T> {
                        type Response = super::MsgRejectPaymentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgRejectPaymentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::reject_payments(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RejectPaymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/CancelPayments" => {
                    #[allow(non_camel_case_types)]
                    struct CancelPaymentsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCancelPaymentsRequest> for CancelPaymentsSvc<T> {
                        type Response = super::MsgCancelPaymentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCancelPaymentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::cancel_payments(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelPaymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/ChangePaymentTarget" => {
                    #[allow(non_camel_case_types)]
                    struct ChangePaymentTargetSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgChangePaymentTargetRequest>
                        for ChangePaymentTargetSvc<T>
                    {
                        type Response = super::MsgChangePaymentTargetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgChangePaymentTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::change_payment_target(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChangePaymentTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/GovCreateMarket" => {
                    #[allow(non_camel_case_types)]
                    struct GovCreateMarketSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgGovCreateMarketRequest>
                        for GovCreateMarketSvc<T>
                    {
                        type Response = super::MsgGovCreateMarketResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgGovCreateMarketRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::gov_create_market(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GovCreateMarketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/GovManageFees" => {
                    #[allow(non_camel_case_types)]
                    struct GovManageFeesSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgGovManageFeesRequest> for GovManageFeesSvc<T> {
                        type Response = super::MsgGovManageFeesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgGovManageFeesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::gov_manage_fees(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GovManageFeesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/GovCloseMarket" => {
                    #[allow(non_camel_case_types)]
                    struct GovCloseMarketSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgGovCloseMarketRequest> for GovCloseMarketSvc<T> {
                        type Response = super::MsgGovCloseMarketResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgGovCloseMarketRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::gov_close_market(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GovCloseMarketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/GovUpdateParams" => {
                    #[allow(non_camel_case_types)]
                    struct GovUpdateParamsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgGovUpdateParamsRequest>
                        for GovUpdateParamsSvc<T>
                    {
                        type Response = super::MsgGovUpdateParamsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgGovUpdateParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::gov_update_params(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GovUpdateParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Msg/UpdateParams" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateParamsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgUpdateParamsRequest> for UpdateParamsSvc<T> {
                        type Response = super::MsgUpdateParamsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgUpdateParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Msg>::update_params(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "provenance.exchange.v1.Msg";
    impl<T> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// GenesisState is the data that should be loaded into the exchange module during genesis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// params defines all the parameters of the exchange module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    /// markets are all of the markets to create at genesis.
    #[prost(message, repeated, tag = "2")]
    pub markets: ::prost::alloc::vec::Vec<Market>,
    /// orders are all the orders to create at genesis.
    #[prost(message, repeated, tag = "3")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// last_market_id is the value of the last auto-selected market id.
    #[prost(uint32, tag = "4")]
    pub last_market_id: u32,
    /// last_order_id is the value of the last order id created.
    #[prost(uint64, tag = "5")]
    pub last_order_id: u64,
    /// commitments are all of the commitments to create at genesis.
    #[prost(message, repeated, tag = "6")]
    pub commitments: ::prost::alloc::vec::Vec<Commitment>,
    /// payments are all the payments to create at genesis.
    #[prost(message, repeated, tag = "7")]
    pub payments: ::prost::alloc::vec::Vec<Payment>,
}
/// QueryOrderFeeCalcRequest is a request message for the OrderFeeCalc query.
/// Exactly one of ask_order or bid_order must be provided.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOrderFeeCalcRequest {
    /// ask_order is the ask order to calculate the fees for.
    #[prost(message, optional, tag = "2")]
    pub ask_order: ::core::option::Option<AskOrder>,
    /// bid_order is the bid order to calculate the fees for.
    #[prost(message, optional, tag = "3")]
    pub bid_order: ::core::option::Option<BidOrder>,
}
/// QueryOrderFeeCalcResponse is a response message for the OrderFeeCalc query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOrderFeeCalcResponse {
    /// creation_fee_options are the order creation flat fee options available for creating the provided order.
    /// If it's empty, no order creation fee is required.
    /// When creating the order, you should include exactly one of these.
    #[prost(message, repeated, tag = "1")]
    pub creation_fee_options:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// settlement_flat_fee_options are the settlement flat fee options available for the provided order.
    /// If it's empty, no settlement flat fee is required.
    /// When creating an order, you should include exactly one of these in the settlement fees field.
    #[prost(message, repeated, tag = "2")]
    pub settlement_flat_fee_options:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// settlement_ratio_fee_options are the settlement ratio fee options available for the provided order.
    /// If it's empty, no settlement ratio fee is required.
    ///
    /// If the provided order was a bid order, you should include exactly one of these in the settlement fees field.
    /// If the flat and ratio options you've chose have the same denom, a single entry should be included with their sum.
    ///
    /// If the provided order was an ask order, these are purely informational and represent how much will be removed
    /// from your price if it settles at that price. If it settles for more, the actual amount will probably be larger.
    #[prost(message, repeated, tag = "3")]
    pub settlement_ratio_fee_options:
        ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// QueryGetOrderRequest is a request message for the GetOrder query.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetOrderRequest {
    /// order_id is the id of the order to look up.
    #[prost(uint64, tag = "1")]
    pub order_id: u64,
}
/// QueryGetOrderResponse is a response message for the GetOrder query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetOrderResponse {
    /// order is the requested order.
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
}
/// QueryGetOrderByExternalIDRequest is a request message for the GetOrderByExternalID query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetOrderByExternalIdRequest {
    /// market_id is the id of the market that's expected to have the order.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// external_id the external id to look up.
    #[prost(string, tag = "2")]
    pub external_id: ::prost::alloc::string::String,
}
/// QueryGetOrderByExternalIDResponse is a response message for the GetOrderByExternalID query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetOrderByExternalIdResponse {
    /// order is the requested order.
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
}
/// QueryGetMarketOrdersRequest is a request message for the GetMarketOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetMarketOrdersRequest {
    /// market_id is the id of the market to get all the orders for.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// order_type is optional and can limit orders to only "ask" or "bid" orders.
    #[prost(string, tag = "2")]
    pub order_type: ::prost::alloc::string::String,
    /// after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.
    #[prost(uint64, tag = "3")]
    pub after_order_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetMarketOrdersResponse is a response message for the GetMarketOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetMarketOrdersResponse {
    /// orders are a page of the orders in the provided market.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetOwnerOrdersRequest is a request message for the GetOwnerOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetOwnerOrdersRequest {
    /// owner is the bech32 address string of the owner to get the orders for.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// order_type is optional and can limit orders to only "ask" or "bid" orders.
    #[prost(string, tag = "2")]
    pub order_type: ::prost::alloc::string::String,
    /// after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.
    #[prost(uint64, tag = "3")]
    pub after_order_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetOwnerOrdersResponse is a response message for the GetOwnerOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetOwnerOrdersResponse {
    /// orders are a page of the orders for the provided address.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetAssetOrdersRequest is a request message for the GetAssetOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAssetOrdersRequest {
    /// asset is the denom of assets to get orders for.
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// order_type is optional and can limit orders to only "ask" or "bid" orders.
    #[prost(string, tag = "2")]
    pub order_type: ::prost::alloc::string::String,
    /// after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.
    #[prost(uint64, tag = "3")]
    pub after_order_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetAssetOrdersResponse is a response message for the GetAssetOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAssetOrdersResponse {
    /// orders are a page of the orders for the provided asset.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetAllOrdersRequest is a request message for the GetAllOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllOrdersRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetAllOrdersResponse is a response message for the GetAllOrders query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllOrdersResponse {
    /// orders are a page of the all orders.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetCommitmentRequest is a request message for the GetCommitment query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetCommitmentRequest {
    /// account is the bech32 address string of the account in the commitment.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// market_id is the numeric identifier of the market in the commitment.
    #[prost(uint32, tag = "2")]
    pub market_id: u32,
}
/// QueryGetCommitmentResponse is a response message for the GetCommitment query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetCommitmentResponse {
    /// amount is the total funds committed to the market by the account.
    #[prost(message, repeated, tag = "1")]
    pub amount: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// QueryGetAccountCommitmentsRequest is a request message for the GetAccountCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAccountCommitmentsRequest {
    /// account is the bech32 address string of the account with the commitments.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    /// denom is an optional denom that, if provided, limits the results to just that denom.
    #[prost(string, tag = "2")]
    pub denom: ::prost::alloc::string::String,
}
/// QueryGetAccountCommitmentsResponse is a response message for the GetAccountCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAccountCommitmentsResponse {
    /// commitments is the amounts committed from the account to the any market.
    #[prost(message, repeated, tag = "1")]
    pub commitments: ::prost::alloc::vec::Vec<MarketAmount>,
}
/// QueryGetMarketCommitmentsRequest is a request message for the GetMarketCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetMarketCommitmentsRequest {
    /// market_id is the numeric identifier of the market with the commitment.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetMarketCommitmentsResponse is a response message for the GetMarketCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetMarketCommitmentsResponse {
    /// commitments is the amounts committed to the market from any account.
    #[prost(message, repeated, tag = "1")]
    pub commitments: ::prost::alloc::vec::Vec<AccountAmount>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetAllCommitmentsRequest is a request message for the GetAllCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllCommitmentsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetAllCommitmentsResponse is a response message for the GetAllCommitments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllCommitmentsResponse {
    /// commitments is the requested commitment information.
    #[prost(message, repeated, tag = "1")]
    pub commitments: ::prost::alloc::vec::Vec<Commitment>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetMarketRequest is a request message for the GetMarket query.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetMarketRequest {
    /// market_id is the id of the market to look up.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
}
/// QueryGetMarketResponse is a response message for the GetMarket query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetMarketResponse {
    /// address is the bech32 address string of this market's account.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// market is all information and details of the market.
    #[prost(message, optional, tag = "2")]
    pub market: ::core::option::Option<Market>,
}
/// QueryGetAllMarketsRequest is a request message for the GetAllMarkets query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllMarketsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetAllMarketsResponse is a response message for the GetAllMarkets query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllMarketsResponse {
    /// markets are a page of the briefs for all markets.
    #[prost(message, repeated, tag = "1")]
    pub markets: ::prost::alloc::vec::Vec<MarketBrief>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryParamsRequest is a request message for the Params query.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
/// QueryParamsResponse is a response message for the Params query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params are the exchange module parameter values.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
/// QueryCommitmentSettlementFeeCalcRequest is a request message for the CommitmentSettlementFeeCalc query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCommitmentSettlementFeeCalcRequest {
    /// settlement is a market's commitment settlement request message.
    /// If no inputs are provided, only the to_fee_nav field will be populated in the response.
    #[prost(message, optional, tag = "1")]
    pub settlement: ::core::option::Option<MsgMarketCommitmentSettleRequest>,
    /// include_breakdown_fields controls the fields that are populated in the response.
    /// If false, only the exchange_fees field is populated.
    /// If true, all of the fields are populated as possible.
    /// If the settlement does not have any inputs, this field defaults to true.
    #[prost(bool, tag = "2")]
    pub include_breakdown_fields: bool,
}
/// QueryCommitmentSettlementFeeCalcResponse is a response message for the CommitmentSettlementFeeCalc query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCommitmentSettlementFeeCalcResponse {
    /// exchange_fees is the total that the exchange would currently pay for the provided settlement.
    #[prost(message, repeated, tag = "1")]
    pub exchange_fees: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// input_total is the sum of all the inputs in the provided settlement.
    #[prost(message, repeated, tag = "2")]
    pub input_total: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// converted_total is the input_total converted to a single intermediary denom or left as the fee denom.
    #[prost(message, repeated, tag = "3")]
    pub converted_total: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// conversion_navs are the NAVs used to convert the input_total to the converted_total.
    #[prost(message, repeated, tag = "4")]
    pub conversion_navs: ::prost::alloc::vec::Vec<NetAssetPrice>,
    /// to_fee_nav is the NAV used to convert the converted_total into the fee denom.
    #[prost(message, optional, tag = "5")]
    pub to_fee_nav: ::core::option::Option<NetAssetPrice>,
}
/// QueryValidateCreateMarketRequest is a request message for the ValidateCreateMarket query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidateCreateMarketRequest {
    /// create_market_request is the request to run validation on.
    #[prost(message, optional, tag = "1")]
    pub create_market_request: ::core::option::Option<MsgGovCreateMarketRequest>,
}
/// QueryValidateCreateMarketResponse is a response message for the ValidateCreateMarket query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidateCreateMarketResponse {
    /// error is any problems or inconsistencies in the provided gov prop msg.
    /// This goes above and beyond the validation done when actually processing the governance proposal.
    /// If an error is returned, and gov_prop_will_pass is true, it means the error is more of an
    /// inconsistency that might cause certain aspects of the market to behave unexpectedly.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    /// gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it's voting
    /// period (assuming it passes).
    #[prost(bool, tag = "2")]
    pub gov_prop_will_pass: bool,
}
/// QueryValidateMarketRequest is a request message for the ValidateMarket query.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryValidateMarketRequest {
    /// market_id is the id of the market to check.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
}
/// QueryValidateMarketResponse is a response message for the ValidateMarket query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidateMarketResponse {
    /// error is any problems or inconsistencies in the provided market.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// QueryValidateManageFeesRequest is a request message for the ValidateManageFees query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidateManageFeesRequest {
    /// manage_fees_request is the request to run validation on.
    #[prost(message, optional, tag = "1")]
    pub manage_fees_request: ::core::option::Option<MsgGovManageFeesRequest>,
}
/// QueryValidateManageFeesResponse is a response message for the ValidateManageFees query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidateManageFeesResponse {
    /// error is any problems or inconsistencies in the provided gov prop msg.
    /// This goes above and beyond the validation done when actually processing the governance proposal.
    /// If an error is returned, and gov_prop_will_pass is true, it means the error is more of an
    /// inconsistency that might cause certain aspects of the market to behave unexpectedly.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    /// gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it's voting
    /// period (assuming it passes).
    #[prost(bool, tag = "2")]
    pub gov_prop_will_pass: bool,
}
/// QueryGetPaymentRequest is a request message for the GetPayment query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentRequest {
    /// source is the source account of the payment to get.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// external_id is the external id of the payment to get.
    #[prost(string, tag = "2")]
    pub external_id: ::prost::alloc::string::String,
}
/// QueryGetPaymentResponse is a response message for the GetPayment query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentResponse {
    /// payment is the info on the requested payment.
    #[prost(message, optional, tag = "1")]
    pub payment: ::core::option::Option<Payment>,
}
/// QueryGetPaymentsWithSourceRequest is a request message for the GetPaymentsWithSource query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentsWithSourceRequest {
    /// source is the source account of the payments to get.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetPaymentsWithSourceResponse is a response message for the GetPaymentsWithSource query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentsWithSourceResponse {
    /// payments is all the payments with the requested source.
    #[prost(message, repeated, tag = "1")]
    pub payments: ::prost::alloc::vec::Vec<Payment>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetPaymentsWithTargetRequest is a request message for the GetPaymentsWithTarget query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentsWithTargetRequest {
    /// target is the target account of the payments to get.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetPaymentsWithTargetResponse is a response message for the GetPaymentsWithTarget query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPaymentsWithTargetResponse {
    /// payments is all the payments with the requested target.
    #[prost(message, repeated, tag = "1")]
    pub payments: ::prost::alloc::vec::Vec<Payment>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryGetAllPaymentsRequest is a request message for the GetAllPayments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllPaymentsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
/// QueryGetAllPaymentsResponse is a response message for the GetAllPayments query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAllPaymentsResponse {
    /// payments is all the payments on this page of results.
    #[prost(message, repeated, tag = "1")]
    pub payments: ::prost::alloc::vec::Vec<Payment>,
    /// pagination is the resulting pagination parameters.
    #[prost(message, optional, tag = "99")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
/// QueryPaymentFeeCalcRequest is a request message for the PaymentFeeCalc query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPaymentFeeCalcRequest {
    /// payment is the details of the payment to create or accept.
    #[prost(message, optional, tag = "1")]
    pub payment: ::core::option::Option<Payment>,
}
/// QueryPaymentFeeCalcResponse is a response message for the PaymentFeeCalc query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPaymentFeeCalcResponse {
    /// fee_create is the fee required to create the provided payment.
    #[prost(message, repeated, tag = "1")]
    pub fee_create: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// fee_accept is the fee required to accept the provided payment.
    #[prost(message, repeated, tag = "2")]
    pub fee_accept: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// Generated client implementations.
#[cfg(feature = "grpc")]
#[cfg_attr(docsrs, doc(cfg(feature = "grpc")))]
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Query is the service for exchange module's query endpoints.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "grpc-transport")]
    #[cfg_attr(docsrs, doc(cfg(feature = "grpc-transport")))]
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// OrderFeeCalc calculates the fees that will be associated with the provided order.
        pub async fn order_fee_calc(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryOrderFeeCalcRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryOrderFeeCalcResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/OrderFeeCalc");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "OrderFeeCalc",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetOrder looks up an order by id.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetOrderResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetOrder");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Query", "GetOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// GetOrderByExternalID looks up an order by market id and external id.
        pub async fn get_order_by_external_id(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetOrderByExternalIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetOrderByExternalIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetOrderByExternalID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetOrderByExternalID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetMarketOrders looks up the orders in a market.
        pub async fn get_market_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetMarketOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetMarketOrdersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetMarketOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetMarketOrders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetOwnerOrders looks up the orders from the provided owner address.
        pub async fn get_owner_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetOwnerOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetOwnerOrdersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetOwnerOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetOwnerOrders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetAssetOrders looks up the orders for a specific asset denom.
        pub async fn get_asset_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAssetOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAssetOrdersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetAssetOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAssetOrders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetAllOrders gets all orders in the exchange module.
        pub async fn get_all_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAllOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllOrdersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetAllOrders");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAllOrders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetCommitment gets the funds in an account that are committed to the market.
        pub async fn get_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetCommitmentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetCommitment");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetCommitment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetAccountCommitments gets all the funds in an account that are committed to any market.
        /// Optionally, you can filter the results for a specific denomination using the `denom` query parameter.
        pub async fn get_account_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAccountCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetAccountCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetAccountCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAccountCommitments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetMarketCommitments gets all the funds committed to a market from any account.
        pub async fn get_market_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetMarketCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetMarketCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetMarketCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetMarketCommitments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetAllCommitments gets all fund committed to any market from any account.
        pub async fn get_all_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAllCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetAllCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetAllCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAllCommitments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetMarket returns all the information and details about a market.
        pub async fn get_market(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetMarketResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetMarket");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Query", "GetMarket"));
            self.inner.unary(req, path, codec).await
        }
        /// GetAllMarkets returns brief information about each market.
        pub async fn get_all_markets(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAllMarketsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllMarketsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetAllMarkets");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAllMarkets",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Params returns the exchange module parameters.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryParamsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/Params");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("provenance.exchange.v1.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// CommitmentSettlementFeeCalc calculates the fees a market will pay for a commitment settlement using current NAVs.
        pub async fn commitment_settlement_fee_calc(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCommitmentSettlementFeeCalcRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCommitmentSettlementFeeCalcResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/CommitmentSettlementFeeCalc",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "CommitmentSettlementFeeCalc",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ValidateCreateMarket checks the provided MsgGovCreateMarketResponse and returns any errors it might have.
        pub async fn validate_create_market(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidateCreateMarketRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidateCreateMarketResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/ValidateCreateMarket",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "ValidateCreateMarket",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ValidateMarket checks for any problems with a market's setup.
        pub async fn validate_market(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidateMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryValidateMarketResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/ValidateMarket",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "ValidateMarket",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ValidateManageFees checks the provided MsgGovManageFeesRequest and returns any errors that it might have.
        pub async fn validate_manage_fees(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidateManageFeesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidateManageFeesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/ValidateManageFees",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "ValidateManageFees",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetPayment gets a single specific payment.
        pub async fn get_payment(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetPaymentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/provenance.exchange.v1.Query/GetPayment");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetPayment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetPaymentsWithSource gets all payments with a specific source account.
        pub async fn get_payments_with_source(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetPaymentsWithSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPaymentsWithSourceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetPaymentsWithSource",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetPaymentsWithSource",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetPaymentsWithTarget gets all payments with a specific target account.
        pub async fn get_payments_with_target(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetPaymentsWithTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPaymentsWithTargetResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetPaymentsWithTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetPaymentsWithTarget",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetAllPayments gets all payments.
        pub async fn get_all_payments(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetAllPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllPaymentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/GetAllPayments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "GetAllPayments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// PaymentFeeCalc calculates the fees that must be paid for creating or accepting a specific payment.
        pub async fn payment_fee_calc(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPaymentFeeCalcRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPaymentFeeCalcResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/provenance.exchange.v1.Query/PaymentFeeCalc",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "provenance.exchange.v1.Query",
                "PaymentFeeCalc",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "grpc")]
#[cfg_attr(docsrs, doc(cfg(feature = "grpc")))]
pub mod query_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServer.
    #[async_trait]
    pub trait Query: std::marker::Send + std::marker::Sync + 'static {
        /// OrderFeeCalc calculates the fees that will be associated with the provided order.
        async fn order_fee_calc(
            &self,
            request: tonic::Request<super::QueryOrderFeeCalcRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryOrderFeeCalcResponse>, tonic::Status>;
        /// GetOrder looks up an order by id.
        async fn get_order(
            &self,
            request: tonic::Request<super::QueryGetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetOrderResponse>, tonic::Status>;
        /// GetOrderByExternalID looks up an order by market id and external id.
        async fn get_order_by_external_id(
            &self,
            request: tonic::Request<super::QueryGetOrderByExternalIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetOrderByExternalIdResponse>,
            tonic::Status,
        >;
        /// GetMarketOrders looks up the orders in a market.
        async fn get_market_orders(
            &self,
            request: tonic::Request<super::QueryGetMarketOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetMarketOrdersResponse>, tonic::Status>;
        /// GetOwnerOrders looks up the orders from the provided owner address.
        async fn get_owner_orders(
            &self,
            request: tonic::Request<super::QueryGetOwnerOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetOwnerOrdersResponse>, tonic::Status>;
        /// GetAssetOrders looks up the orders for a specific asset denom.
        async fn get_asset_orders(
            &self,
            request: tonic::Request<super::QueryGetAssetOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAssetOrdersResponse>, tonic::Status>;
        /// GetAllOrders gets all orders in the exchange module.
        async fn get_all_orders(
            &self,
            request: tonic::Request<super::QueryGetAllOrdersRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllOrdersResponse>, tonic::Status>;
        /// GetCommitment gets the funds in an account that are committed to the market.
        async fn get_commitment(
            &self,
            request: tonic::Request<super::QueryGetCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetCommitmentResponse>, tonic::Status>;
        /// GetAccountCommitments gets all the funds in an account that are committed to any market.
        /// Optionally, you can filter the results for a specific denomination using the `denom` query parameter.
        async fn get_account_commitments(
            &self,
            request: tonic::Request<super::QueryGetAccountCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetAccountCommitmentsResponse>,
            tonic::Status,
        >;
        /// GetMarketCommitments gets all the funds committed to a market from any account.
        async fn get_market_commitments(
            &self,
            request: tonic::Request<super::QueryGetMarketCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetMarketCommitmentsResponse>,
            tonic::Status,
        >;
        /// GetAllCommitments gets all fund committed to any market from any account.
        async fn get_all_commitments(
            &self,
            request: tonic::Request<super::QueryGetAllCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetAllCommitmentsResponse>,
            tonic::Status,
        >;
        /// GetMarket returns all the information and details about a market.
        async fn get_market(
            &self,
            request: tonic::Request<super::QueryGetMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetMarketResponse>, tonic::Status>;
        /// GetAllMarkets returns brief information about each market.
        async fn get_all_markets(
            &self,
            request: tonic::Request<super::QueryGetAllMarketsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllMarketsResponse>, tonic::Status>;
        /// Params returns the exchange module parameters.
        async fn params(
            &self,
            request: tonic::Request<super::QueryParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryParamsResponse>, tonic::Status>;
        /// CommitmentSettlementFeeCalc calculates the fees a market will pay for a commitment settlement using current NAVs.
        async fn commitment_settlement_fee_calc(
            &self,
            request: tonic::Request<super::QueryCommitmentSettlementFeeCalcRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCommitmentSettlementFeeCalcResponse>,
            tonic::Status,
        >;
        /// ValidateCreateMarket checks the provided MsgGovCreateMarketResponse and returns any errors it might have.
        async fn validate_create_market(
            &self,
            request: tonic::Request<super::QueryValidateCreateMarketRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidateCreateMarketResponse>,
            tonic::Status,
        >;
        /// ValidateMarket checks for any problems with a market's setup.
        async fn validate_market(
            &self,
            request: tonic::Request<super::QueryValidateMarketRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryValidateMarketResponse>, tonic::Status>;
        /// ValidateManageFees checks the provided MsgGovManageFeesRequest and returns any errors that it might have.
        async fn validate_manage_fees(
            &self,
            request: tonic::Request<super::QueryValidateManageFeesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidateManageFeesResponse>,
            tonic::Status,
        >;
        /// GetPayment gets a single specific payment.
        async fn get_payment(
            &self,
            request: tonic::Request<super::QueryGetPaymentRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetPaymentResponse>, tonic::Status>;
        /// GetPaymentsWithSource gets all payments with a specific source account.
        async fn get_payments_with_source(
            &self,
            request: tonic::Request<super::QueryGetPaymentsWithSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPaymentsWithSourceResponse>,
            tonic::Status,
        >;
        /// GetPaymentsWithTarget gets all payments with a specific target account.
        async fn get_payments_with_target(
            &self,
            request: tonic::Request<super::QueryGetPaymentsWithTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPaymentsWithTargetResponse>,
            tonic::Status,
        >;
        /// GetAllPayments gets all payments.
        async fn get_all_payments(
            &self,
            request: tonic::Request<super::QueryGetAllPaymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryGetAllPaymentsResponse>, tonic::Status>;
        /// PaymentFeeCalc calculates the fees that must be paid for creating or accepting a specific payment.
        async fn payment_fee_calc(
            &self,
            request: tonic::Request<super::QueryPaymentFeeCalcRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPaymentFeeCalcResponse>, tonic::Status>;
    }
    /// Query is the service for exchange module's query endpoints.
    #[derive(Debug)]
    pub struct QueryServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> QueryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServer<T>
    where
        T: Query,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/provenance.exchange.v1.Query/OrderFeeCalc" => {
                    #[allow(non_camel_case_types)]
                    struct OrderFeeCalcSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryOrderFeeCalcRequest> for OrderFeeCalcSvc<T> {
                        type Response = super::QueryOrderFeeCalcResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryOrderFeeCalcRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::order_fee_calc(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OrderFeeCalcSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetOrder" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrderSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetOrderRequest> for GetOrderSvc<T> {
                        type Response = super::QueryGetOrderResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Query>::get_order(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetOrderByExternalID" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrderByExternalIDSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryGetOrderByExternalIdRequest>
                        for GetOrderByExternalIDSvc<T>
                    {
                        type Response = super::QueryGetOrderByExternalIdResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetOrderByExternalIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_order_by_external_id(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrderByExternalIDSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetMarketOrders" => {
                    #[allow(non_camel_case_types)]
                    struct GetMarketOrdersSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetMarketOrdersRequest>
                        for GetMarketOrdersSvc<T>
                    {
                        type Response = super::QueryGetMarketOrdersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetMarketOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_market_orders(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMarketOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetOwnerOrders" => {
                    #[allow(non_camel_case_types)]
                    struct GetOwnerOrdersSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetOwnerOrdersRequest>
                        for GetOwnerOrdersSvc<T>
                    {
                        type Response = super::QueryGetOwnerOrdersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetOwnerOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_owner_orders(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOwnerOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAssetOrders" => {
                    #[allow(non_camel_case_types)]
                    struct GetAssetOrdersSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetAssetOrdersRequest>
                        for GetAssetOrdersSvc<T>
                    {
                        type Response = super::QueryGetAssetOrdersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAssetOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_asset_orders(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAssetOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAllOrders" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllOrdersSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetAllOrdersRequest> for GetAllOrdersSvc<T> {
                        type Response = super::QueryGetAllOrdersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAllOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::get_all_orders(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetCommitment" => {
                    #[allow(non_camel_case_types)]
                    struct GetCommitmentSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetCommitmentRequest>
                        for GetCommitmentSvc<T>
                    {
                        type Response = super::QueryGetCommitmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetCommitmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::get_commitment(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCommitmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAccountCommitments" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountCommitmentsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryGetAccountCommitmentsRequest>
                        for GetAccountCommitmentsSvc<T>
                    {
                        type Response = super::QueryGetAccountCommitmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAccountCommitmentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_account_commitments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountCommitmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetMarketCommitments" => {
                    #[allow(non_camel_case_types)]
                    struct GetMarketCommitmentsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryGetMarketCommitmentsRequest>
                        for GetMarketCommitmentsSvc<T>
                    {
                        type Response = super::QueryGetMarketCommitmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetMarketCommitmentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_market_commitments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMarketCommitmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAllCommitments" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllCommitmentsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetAllCommitmentsRequest>
                        for GetAllCommitmentsSvc<T>
                    {
                        type Response = super::QueryGetAllCommitmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAllCommitmentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_all_commitments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllCommitmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetMarket" => {
                    #[allow(non_camel_case_types)]
                    struct GetMarketSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetMarketRequest> for GetMarketSvc<T> {
                        type Response = super::QueryGetMarketResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetMarketRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::get_market(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMarketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAllMarkets" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllMarketsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetAllMarketsRequest>
                        for GetAllMarketsSvc<T>
                    {
                        type Response = super::QueryGetAllMarketsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAllMarketsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::get_all_markets(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllMarketsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/Params" => {
                    #[allow(non_camel_case_types)]
                    struct ParamsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryParamsRequest> for ParamsSvc<T> {
                        type Response = super::QueryParamsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Query>::params(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/CommitmentSettlementFeeCalc" => {
                    #[allow(non_camel_case_types)]
                    struct CommitmentSettlementFeeCalcSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryCommitmentSettlementFeeCalcRequest>
                        for CommitmentSettlementFeeCalcSvc<T>
                    {
                        type Response = super::QueryCommitmentSettlementFeeCalcResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryCommitmentSettlementFeeCalcRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::commitment_settlement_fee_calc(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CommitmentSettlementFeeCalcSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/ValidateCreateMarket" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateCreateMarketSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryValidateCreateMarketRequest>
                        for ValidateCreateMarketSvc<T>
                    {
                        type Response = super::QueryValidateCreateMarketResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryValidateCreateMarketRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::validate_create_market(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateCreateMarketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/ValidateMarket" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateMarketSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryValidateMarketRequest>
                        for ValidateMarketSvc<T>
                    {
                        type Response = super::QueryValidateMarketResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryValidateMarketRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::validate_market(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateMarketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/ValidateManageFees" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateManageFeesSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryValidateManageFeesRequest>
                        for ValidateManageFeesSvc<T>
                    {
                        type Response = super::QueryValidateManageFeesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryValidateManageFeesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::validate_manage_fees(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateManageFeesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetPayment" => {
                    #[allow(non_camel_case_types)]
                    struct GetPaymentSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetPaymentRequest> for GetPaymentSvc<T> {
                        type Response = super::QueryGetPaymentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetPaymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Query>::get_payment(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPaymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetPaymentsWithSource" => {
                    #[allow(non_camel_case_types)]
                    struct GetPaymentsWithSourceSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryGetPaymentsWithSourceRequest>
                        for GetPaymentsWithSourceSvc<T>
                    {
                        type Response = super::QueryGetPaymentsWithSourceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetPaymentsWithSourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_payments_with_source(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPaymentsWithSourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetPaymentsWithTarget" => {
                    #[allow(non_camel_case_types)]
                    struct GetPaymentsWithTargetSvc<T: Query>(pub Arc<T>);
                    impl<T: Query>
                        tonic::server::UnaryService<super::QueryGetPaymentsWithTargetRequest>
                        for GetPaymentsWithTargetSvc<T>
                    {
                        type Response = super::QueryGetPaymentsWithTargetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetPaymentsWithTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_payments_with_target(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPaymentsWithTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/GetAllPayments" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllPaymentsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryGetAllPaymentsRequest>
                        for GetAllPaymentsSvc<T>
                    {
                        type Response = super::QueryGetAllPaymentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetAllPaymentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::get_all_payments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllPaymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/provenance.exchange.v1.Query/PaymentFeeCalc" => {
                    #[allow(non_camel_case_types)]
                    struct PaymentFeeCalcSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryPaymentFeeCalcRequest>
                        for PaymentFeeCalcSvc<T>
                    {
                        type Response = super::QueryPaymentFeeCalcResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryPaymentFeeCalcRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::payment_fee_calc(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PaymentFeeCalcSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for QueryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "provenance.exchange.v1.Query";
    impl<T> tonic::server::NamedService for QueryServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
